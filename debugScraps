//debug scraps

//intersect lines
if (debugMode){
	circles.forEach (function (circle) {
		ctx.beginPath();
		ctx.strokeStyle='#00FFFF'; //cyan
		var perpedicularLines = perpendicularVector (vectorOfLine(line), circle.radius);	
		var collisionLine1 = translateLine (line, perpedicularLines[0])
		var collisionLine2 = translateLine (line, perpedicularLines[1])
		ctx.moveTo (collisionLine1.x1, collisionLine1.y1);
		ctx.lineTo (collisionLine1.x2, collisionLine1.y2);
		ctx.moveTo (collisionLine2.x1, collisionLine2.y1);
		ctx.lineTo (collisionLine2.x2, collisionLine2.y2);
		ctx.stroke();

		//Draw the intersecting points
		ctx.beginPath();
		//ctx.strokeStyle='#FF0000'; // red
		var circleEndPoint = {
			x : circle.x + circle.vel.x,
			y :	circle.y + circle.vel.y
		}
		var circleLine = {x1: circle.x, y1: circle.y, x2: circle.x + circle.vel.x, y2: circle.y + circle.vel.y};
		//console.log ("get intersections");
		var interPoint1 = intersectionOfLines(circleLine, collisionLine1);
		var interPoint2 = intersectionOfLines(circleLine, collisionLine2);
		//console.log ("get distances");

		if (interPoint1 != null && interPoint2 != null) {
			var collisionDistance1 = relativeDistanceBetweenPoints({x : circle.x, y : circle.y}, circleEndPoint, interPoint1);
			var collisionDistance2 = relativeDistanceBetweenPoints({x : circle.x, y : circle.y}, circleEndPoint, interPoint2);

			var closerCollisionPoint = null;
			var fartherCollisionPoint = null;

				//This is actually enough to check because if the distance would be negative, the collision won't happen anyways
			if (Math.abs(collisionDistance1) < Math.abs(collisionDistance2)) {
				closerCollisionPoint = interPoint1;
				fartherCollisionPoint = interPoint2;
			} else {
				closerCollisionPoint = interPoint2;
				fartherCollisionPoint = interPoint1;
			}

			//console.log ("drawing the intersections");
			if (closerCollisionPoint != null){
				ctx.strokeStyle = '#00FF00'; // green
				ctx.moveTo(closerCollisionPoint.x - indentLength, closerCollisionPoint.y);
				ctx.lineTo(closerCollisionPoint.x + indentLength, closerCollisionPoint.y);
				ctx.stroke();
				ctx.beginPath();
			}
			//console.log ("first intersection");

			if (fartherCollisionPoint != null){
				ctx.strokeStyle='#FF0000'; // red
				ctx.moveTo(fartherCollisionPoint.x - indentLength, fartherCollisionPoint.y);
				ctx.lineTo(fartherCollisionPoint.x + indentLength, fartherCollisionPoint.y);
				ctx.stroke();
				ctx.beginPath();
			}
			/*
			if (interPoint1 != null){
				ctx.moveTo(interPoint1.x - indentLength, interPoint1.y);
				ctx.lineTo(interPoint1.x + indentLength, interPoint1.y);
			}
			if (interPoint2 != null){
				ctx.moveTo(interPoint2.x - indentLength, interPoint2.y);
				ctx.lineTo(interPoint2.x + indentLength, interPoint2.y);
			}
			*/
		}
	});
	//Draw the bordering lines
}

//line segment collisions
					/*
					if (lineCollision.shape != null){
						console.log ("line segment collision");
						console.log (lineCollision.shape);
						console.log (lineCollision.time);
					}
					if (point1Collision.shape != null){
						console.log ("point1 segment collision");
						console.log (point1Collision.shape);
						console.log (point1Collision.time);
					}
					if (point2Collision.shape != null){
						console.log ("point2 segment collision");
						console.log (point2Collision.shape);
						console.log (point2Collision.time);
					}
					*/
					
					
					//} else {

						/*
	lineSegments = [
		{x1 : 0, y1 : height/2, x2 : width/2, y2 : 0},
		{x1 : width/2, y1 : 0, x2 : width, y2 : height/2},
		{x1 : width, y1 : height/2, x2 : width/2, y2 : height},
		{x1 : width/2, y1 : height, x2 : 0, y2 : height/2}
	];
	*/

	/*
		points = [
		{x : 100, y : 100},
		{x : 200, y : 100},
		{x : 300, y : 100},
		{x : 400, y : 100},

		{x : 100, y : 200},
		{x : 200, y : 200},
		{x : 300, y : 200},
		{x : 400, y : 200},

		{x : 100, y : 300},
		{x : 200, y : 300},
		{x : 300, y : 300},
		{x : 400, y : 300},

		{x : 100, y : 400},
		{x : 200, y : 400},
		{x : 300, y : 400},
		{x : 400, y : 400}
		];
		*/
